function measurelut% Measure LUT of a monitor using the Minolta LS-110 luminance meter% It will measure luminances of individual guns as well as of gray% Most reliable with Minolta set to "Fast" response%% Send comments and bug reports to: f.w.cornelissen@med.rug.nl%% History%%	24-06-2000	FWC	Created it based on c-code version%	26-09-2000	FWC added comments, added dialog for output file% 	20-01-2002	fwc	changed for use with new version of minolta toolbox% 	07-04-2002	fwc added ability to expand cal files into lutfiles (with corrections)% 					we now take the calibration data and fit a polynomial to it.% 					this also allows us to expand the LUT file to stepsize 1.%					screen settings can be supplied via a single line!clear all;programname='Measure Monitor LUT';showreadings=1; % show readings on screen during calibrationmodifierkeyname='apple';quitkeyname='esc';modifierkey=KbName(modifierkeyname);quitkey=KbName(quitkeyname);whichScreen=0; % 0 for main screenisColor=1;width=832;height=624;refresh=75;pixelsize=32;fprintf('Welcome to the ''%s'' program.\n\n', programname);par=[];par.screen=[whichScreen width height refresh pixelsize ];par=setdefaultparameters(par);i=0;while 1	par=getparams(par, i);	% check values	[myerr,par]=checkfilenames(par);	if myerr==0		break;	end	i=i+1;	if i>5 % max of five attempts		return;	endend% change port if we're simulatingif par.simulate==1 	par.port=0;endfprintf('Looking for a luminance meter....\n');minolta=initLuminanceMeter(par.port);if minolta.port < 0		fprintf('Luminance meter not found.\n');	return;endfprintf('Starting measurements.\n');quittxt=sprintf('''%s''+''%s'' to quit', modifierkeyname, quitkeyname);fprintf('\n\nPress %s.\n\n', quittxt);% [window, winrect]=setupwindow(whichScreen, width, height, refresh, pixelsize,isColor);[window, winrect]=setupwindow(par.screen(1), par.screen(2), par.screen(3), par.screen(4), par.screen(5), isColor);white=WhiteIndex(window);black=BlackIndex(window);% dit moet nog omgezet worden naar vinden van dac waarde op basis van luminantiepar.bits=SCREEN(window,'Preference','ClutDacSize');par.maxdac=2^par.bits-1;if par.backdac==-1	par.backdac=round(par.maxdac/2);end%fprintf( '\nBits: %d, highdac: %d, backdac: %d\n', bits, maxdac, par.backdac );backcol=[par.backdac par.backdac par.backdac];size=round(par.testrectsize/100*RectWidth(winrect));testrect=[0 0 size size ];testrect = CenterRect(testrect, winrect);screen(window, 'waitblanking');SCREEN(window,'FillRect', backcol);SCREEN(window,'FillRect',black, testrect);SCREEN(window,'FillRect',white, testrect);SCREEN(window,'TextFont','Helvetica');SCREEN(window,'TextSize',par.fontsize);txt='Aim Minolta at central square';SCREEN(window,'DrawText',txt,50,50,white);txt=['Press a key to continue, ' quittxt];SCREEN(window,'DrawText',txt,50,50+par.fontsize*1.5,white);%SCREEN(window,'DrawText',quittxt,50,50+2*par.fontsize*1.5,white);eraserect=winrect;eraserect(4)=eraserect(4)/8;while 1	[keyIsDown,secs,keyCode] = KbCheck;	if keyIsDown		break;	endendhidecursor;tstart=getsecs;while 1	timeleft=par.runawaytime-(getsecs-tstart);		txt=sprintf('You have %.1f s to leave the room (%s) ', timeleft, quittxt);	SCREEN(window,'FillRect', backcol, eraserect);	SCREEN(window,'DrawText',txt,50,50,white);	[keyIsDown,secs,keyCode] = KbCheck;	if keyCode(modifierkey) & keyCode(quitkey)		break;	end	if timeleft < par.runawaystep		waitsecs(timeleft);		break;	end	waitsecs(par.runawaystep);endSCREEN(window,'FillRect', backcol);waitsecs(par.settletime);[backlum, m,t]=getLuminance(minolta);if backlum<0	SCREEN('CloseAll');	closeLuminanceMeter(minolta);	fprintf('Could not get a reading for background luminance.\n');	return;end% create cal and measure luminanceslut=ones(par.guns,par.maxdac+1)*-1;for g=1:par.guns	i=1;	for dac=0:par.dacstep:par.maxdac		switch g			case 1,				colour=[dac 0 0];			case 2,				colour=[0 dac 0];			case 3,				colour=[0 0 dac];			case 4,				colour=[dac dac dac]; % grey			otherwise,				fprintf('Unknown gun...\n');				return;		end		screen(window, 'waitblanking');		SCREEN(window,'FillRect',colour, testrect);		waitsecs(par.settletime);		[lum, m,t]=getLuminance(minolta);		lut(g,dac+1)=lum;		par.cal(g, i)=lum;		par.olddac(i)=dac;		if showreadings==1			SCREEN(window,'FillRect', backcol, eraserect);			txt=sprintf('%s %4d, lum: %.3f', deblank(par.gunname(g,:)), dac, lum);			SCREEN(window,'DrawText',txt,50,50,white);		end		%fprintf( '\nGun#%d: dac: %d, lum: %f', g, dac, lum );			i=i+1;				if mod(i, par.savestep)==0			saveLUTfile( par.outfilename, lut, par.dacstep);		end				[keyIsDown,secs,keyCode] = KbCheck;		if keyCode(modifierkey) & keyCode(quitkey)			break;		end	endendsaveLUTfile( par.outfilename, lut, par.dacstep);fprintf('Saved CAL data to ''%s''.\n', par.outfilename );newlut=createlutfile( par );fprintf('Saved LUT to ''%s''.\n', par.lutfilename );% save a report filefp=fopen( par.reportfilename, 'w');fprintf(fp, 'Report for LUT file: ''%s''.\n', par.outfilename);fprintf(fp, 'This file: ''%s''.\n', par.reportfilename);fprintf(fp, 'Produced by ''%s'' program.\n', programname);fprintf(fp, 'Measurement performed on: %s.\n', datestr(now,0));fprintf(fp, 'Screen: pixelsize: %d w: %d h: %d refresh: %f Hz\n', pixelsize, width, height, refresh);fprintf(fp, 'Clut Dac Size: %d, highest dac value: %d\n', par.bits, par.maxdac );fprintf(fp, 'Background: dac value: %d, lum: %f\n', par.backdac, backlum);fprintf(fp, 'Dac stepsize: %d\n', par.dacstep);fprintf(fp, 'Measurement rect size: %.1f %% of screen (%d x %d pixels)\n', par.testrectsize, size, size);PrintComputerDescription(fp);fprintf(fp, 'End of report\n');fclose(fp);filetype(par.reportfilename,'TEXT','XCEL');fprintf('Saved report to ''%s''.\n', par.reportfilename );SCREEN('CloseAll');closeLuminanceMeter(minolta);FlushEvents('keyDown');fprintf('\nBye!\n\n');%------------------function par=setdefaultparameters(par)par.simulate=0; % 0 to use meter, 1 to simulatepar.port=-1; % serial port to use (-1 to select)par.guns=4;par.gunname=['Red  '; 'Green'; 'Blue '; 'Gray '];par.outfile='dummy';par.outdir='lutfiles';par.fontsize=24;par.backlum=25.0; % which background luminance to usepar.backdac=-1; % set to middle graypar.testrectsize=10;  % percentage of horizontal screensizepar.dacstep=15;par.lutfile=1; % create a LUT file, in addition to the cal file?par.polyorder=3;par.settletime=.25;par.runawaytime=5.0;par.runawaystep=1.0;par.savestep=1; % save after how many measurements?par.calext='.cal';par.lutext='.lut';par.reportext='.txt';%---------------function saveLUTfile( filename, lut, step)% save lum values to file[n,m]=size(lut);if n>1 & m>1	fp=fopen( filename, 'w');	fprintf(fp, 'DAC\tRED\tGREEN\tBLUE\tWHITE\n');	for c=1:step:m		fprintf(fp,'%d', c-1);		for g=1:n			fprintf(fp,'\t%f', lut(g,c));		end		fprintf(fp,'\n');	end	fclose(fp);	filetype(filename,'TEXT','XCEL');end%----------------------------------------------------function data=getparams(data,n)if n==0	dlgtext='Enter parameters for this experiment';else	dlgtext='Sorry, one of the parameters contained an error';end% First, create table of parameter names, default values and promptsParameters = { 															...'outfile',		'dummy',	'Name of file to which to write results';	...'outdir',		'output',	'Folder for result files';					...'screen'		'[0 1 2]',  'Screen settings (number hor vert freq pixelsize)';	...'backdac'		'-1',		'Background dac setting (-1 for middle gray)';	...'testrectsize'	'10.0',		'Size of test rect (as % of screen)';	...'runawaytime', '1.0',		'Time to leave the room'; ...'settletime',  '0.25',		'Time to let screen settle'; ...'dacstep', 		'15',		'DAC Step size'; ...'port'			'-1',		'Serial port to use (-1 to select)';	...'simulate'		'1',		'Simulate meter (1=yes, 0=no)';	...'polyorder'		'3',		'Order of polynomial fitted to cal data';	...};% set defaultsfor i = 1:size(Parameters,1)	if ~isempty(str2num(Parameters{i,2}))		eval([ 'Parameters{' num2str(i) ',2}=num2str(data.' Parameters{i,1} ');']); % for string entries	else		eval([ 'Parameters{' num2str(i) ',2}=data.' Parameters{i,1} ';']); % for number entries	endend% pop up a window to get parameter values.if 1		ParamInputs = inputdlg(Parameters(:,3), dlgtext, 1, Parameters(:,2), 'on');	[Parameters{:,2}] = deal(ParamInputs{:});end% Now assign each parameter in the table to its valuefor i = 1:size(Parameters,1)	if isempty(str2num(Parameters{i,2}))		eval(['data.' Parameters{i,1} '=''' Parameters{i,2} ''';']); % for string entries	else										eval(['data.' Parameters{i,1} '=[' Parameters{i,2} '];']);   % for number entries	endend%-------------------------------------------% setupwindowfunction [w, rect]=setupwindow(whichScreen, width, height, hz, pixelSize,isColor)% open a window of particular size and refresh rate% remember some old settingsres=NearestResolution(whichScreen,width, height, hz, pixelSize);oldRes=SCREEN(whichScreen,'Resolution');[w,rect]=SCREEN(whichScreen,'OpenWindow',0,[],res);%open screenpixelSizes=SCREEN(whichScreen,'PixelSizes');if max(pixelSizes)<pixelSize	fprintf('Sorry, I need a screen that supports %d-bit pixelSize.\n', pixelSize);	return;end[oldPixelSize,oldIsColor,pages]=SCREEN(w,'PixelSize',pixelSize,isColor);oldBoolean=SCREEN(w,'Preference','SetClutDriverWaitsForBlanking',0);white=WhiteIndex(w);black=BlackIndex(w);gray=(white+black)/2;SCREEN(w,'FillRect',gray);%--------------------------------------------------------------------% checkfilenamesfunction [myerr,par]=checkfilenames(par)myerr=1;% Get output file name.outfile=1;i=1;			if strcmp(par.outfile,'test')==1	par.outfile=sprintf('%s%05d', par.outfile, round(rand*100000)-1 ); % add random number to filenameendpar.outfilename=[filesep par.outdir filesep par.outfile par.calext ];outfile=fopen(par.outfilename,'r');if outfile>0	if 1~=strcmp(par.outfile,'dummy') % allow this filename to be overwritten		fprintf('Output file ''%s'' already exists.\n', par.outfilename );		fclose(outfile);		return;	endendpar.reportfilename=[filesep par.outdir filesep par.outfile '_' 'report' par.reportext ];par.lutfilename=[filesep par.outdir filesep par.outfile par.lutext ];myerr=0;%------------------------------------------function newlut=createlutfile(par)% we take the calibration data and fit a polynomial to the data.% this also allows us to expand the LUT file to stepsize 1.newdac=0:par.maxdac;  % one entry for each dac value%filename=[filesep par.outdir filesep par.outfile '.cal' ];%[dac, lut(:,1), lut(:,2), lut(:,3), lut(:,4)]=textread(filename, '%f\t%f\t%f\t%f\t%f', 'headerlines', 1 );if 1	[n,m]=size(par.olddac)	[n,m]=size(par.cal)		par.olddac	par.calendfor i=1:par.guns	[p,s] = polyfit(par.olddac,par.cal(i,:),par.polyorder);	newlut(i,:)=polyval(p, newdac);endif 1	[n,m]=size(newlut);		% correct for any unwanted increases (at low dac values)	for c=1:n		for r=m-1:-1:1			if newlut(c,r+1) < newlut(c,r) | newlut(c,r) < par.cal(c,1)				% replace data by linearly extrapolating between previous value and first measured value				newlut(c,1:r+1)=linspace(par.cal(c,1), newlut(c,r+1), r+1);					break;			end		end	endend% save the new lut data% filename=[filesep lutfiledir filesep lutfilename '.lut' ];fp=fopen( par.lutfilename, 'w');[n,m]=size(newlut);fprintf(fp, 'DAC\tRED\tGREEN\tBLUE\tWHITE\n');for r=1:m	fprintf(fp,'%d', newdac(r));	for c=1:n		fprintf(fp,'\t%f', newlut(c,r));	end	fprintf(fp,'\n');endfclose(fp);filetype(par.lutfilename,'TEXT','XCEL');