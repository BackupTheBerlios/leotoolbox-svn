function varargout=modlcdcal(varargin)% convert LCD display calibration data% USAGE: [modR, modG, modB, Gray]=newconvlcdcal(R,G,B,Gray)% modR, modG, modB, modified CIE values (x y Y), dac= dac values% or USAGE: modxyY=newconvlcdcal(xyY)%  in this case, xyY is a 4 by n rows by 3 (x, y, Y)% array% note: Gray (or channel 4) is unchanged, but is returned for convenience% comments to Frans W. Cornelissen, email: f.w.cornelissen@med.rug.nl% Formulas from Cazes et al. 1999% based on excel example provided by Marcel Lucassen, TNO-HF, Soesterberg% History% 03-02-04  fwc first version as a script% 04-02-04  fwc tidied up code, added OS 9 compatible textread version%               (PC?), changed into a function% 12-02-04  fwc kept only conversion routines, extracted file handling%               variable input and output optionsthisfile=mfilename;if length(varargin)==1    xyY=varargin{1};elseif length(varargin)==4    [xyY(1,:,:) xyY(2,:,:) xyY(3,:,:) xyY(4,:,:)]=deal(varargin{:});else    error([ thisfile  ' requires 1 or 4 input arguments']);end% convert from CIE x,y,Y to trimstimulus XYZ values[k,r,n]=size(xyY);for c=1:k    for j=1:r        myXYZ(c,j,:)=xyYToXYZ(xyY(c,j,:));    endend% get best estimate for dark current by averaging over channelsdarkXYZ=squeeze(mean(myXYZ(:,1,:),1));% correct for dark current contribution% shouldn't we use our best estimate here?for c=1:k    for j=1:r        myXYZ0(c,j,:)=myXYZ(c,j,:)-myXYZ(c,1,:);    endend% convert back to xyY_accent (we're not using this are we?)for c=1:4    for j=1:r        myxyY_accent(c,j,:)=XYZToxyY(myXYZ0(c,j,:));    endend% create matrix with (corrected) xyz values at maximum drive valueM=[ xyY(1,r,1) xyY(2,r,1) xyY(3,r,1);    xyY(1,r,2) xyY(2,r,2) xyY(3,r,2)];% calculate third row   for i=1:3    M(3,i)=1-M(1,i)-M(2,i);end% calculate alpha, beta and gamma values (what do these constitute?)abg=inv(M)*darkXYZ;% calculate r(0), g(0) and b(0) valuesr0=abg(1)*M(:,1);g0=abg(2)*M(:,2);b0=abg(3)*M(:,3);% calculate (expected) gray  channel XYZ values by summing XYZ values for seperate channelsd=size(myXYZ);sumRGBXYZ=reshape(sum(myXYZ(1:3,:,:),1),d(2),d(3));% calculate difference between expected and measured values%first create a tiled matrix with dark current valuesdark=repmat(squeeze(myXYZ(4,1,:)),1,d(2))';LESumRGBXYZ=sumRGBXYZ-squeeze(myXYZ(4,:,:))-2*dark;% calculate relative deviations for each channel? (why is this done with% sums not corrected for summed darkcurrents?% scaling factors are calculated for maximum drive values only!xr=squeeze(myXYZ(1,r,:))'./sumRGBXYZ(r,:);xg=squeeze(myXYZ(2,r,:))'./sumRGBXYZ(r,:);xb=squeeze(myXYZ(3,r,:))'./sumRGBXYZ(r,:);% Calculate Leakage Errors for different channelsLE_R=LESumRGBXYZ.*repmat(xr,d(2),1);LE_G=LESumRGBXYZ.*repmat(xg,d(2),1);LE_B=LESumRGBXYZ.*repmat(xb,d(2),1);% adjusted tristimulus values% we tile (repmat) the r0,g0,b0 matrices so that we can do this MOD_R=squeeze(myXYZ(1,:,:))-repmat(g0,1,d(2))'-repmat(b0,1,d(2))'-LE_R;MOD_G=squeeze(myXYZ(2,:,:))-repmat(r0,1,d(2))'-repmat(b0,1,d(2))'-LE_G;MOD_B=squeeze(myXYZ(3,:,:))-repmat(r0,1,d(2))'-repmat(g0,1,d(2))'-LE_B;% calculate adjusted CIE valuesfor j=1:r    modR(j,:)=XYZToxyY(MOD_R(j,:));    modG(j,:)=XYZToxyY(MOD_G(j,:));    modB(j,:)=XYZToxyY(MOD_B(j,:));endnout = max(nargout,1);if nout==1    temp(1,:,:)=modR;    temp(2,:,:)=modG;    temp(3,:,:)=modB;    temp(4,:,:)=squeeze(xyY(4,:,:));   varargout= {temp};elseif nargout==3   varargout= {modR, modG, modB};elseif nargout==4   varargout= {modR, modG, modB, squeeze(xyY(4,:,:))};end