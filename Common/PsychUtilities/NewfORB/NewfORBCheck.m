function [buttonisdown, trigger, time, forb ]=NewfORBCheck(forb)% check forb for presence of a button press or trigger pulse% USAGE: [buttonisdown, trigger, time, forb ]=NewfORBCheck(forb)%% forb.status holds status of each button and trigger% time is time at which first positive status was reached, or time% when exiting this function in case no positive status is reached.% We block the use of keys when a signal is received via serial ports.%				% history% 			fwc	gebaseerd op oude fORBCheck% 11-2-02	fwc	probleem was dat forbcheck alleen eerste byte analyseerde%				nu lezen we elke byte uit, en geven de "gezamenlijke"%				status door. Tussendoor houden we bij of het signaal terug%				naar 0 gaat, en tellen volgende signalen erbij op. Met name%				van belang voor triggers. buttonisdown=0;trigger=0;checkkb=1;time=-1;forb.prevstatus=forb.status;forb.nbytes=0;forb.status=zeros(forb.nbits,1);waszero=ones(forb.nbits,1);if forb.port > 0 % only if a serial port was succesfully initialized	data=SERIAL('Read',forb.port, forb.timeoutSecs);	if ~isempty(data)		time=GetSecs;		[m,forb.nbytes]=size(data);		for k=1:forb.nbytes % we'll just examine any button pressed since previous check			checkkb=0; % do not override forb buttons with keyboard			for i=1:forb.nbits				if bitand(data(k), forb.bit(i))					if waszero(i)==1						forb.status(i)=forb.status(i) + 1;						waszero(i)=0;					end				else					waszero(i)=1; % reset because signal was released again				end			end		end	endendif checkkb==1 & forb.usekeys==1 % allow use of keyboard input	[keyIsDown,secs,keyCode] = KbCheck;		for i=1:forb.nbits		if keyCode(forb.buttonkey(i))==1			forb.status(i)=1;			if time==-1				time=secs;			end		else			forb.status(i)=0;		end	endend% simulate a scanner trigger pulse (when simulation has started)if forb.scanner.simulate==1 & forb.scanner.start >=0	tijd1=getsecs-forb.scanner.start;		% hoeveel volumes zijn er al "gescand"?	volumecount=floor(tijd1/forb.scanner.TR);	tijd2=tijd1-volumecount*forb.scanner.TR;		% kijk of er nog slices moeten worden "gescand" in huidige volume	if tijd2 <= forb.scanner.sliceinterval*(forb.scanner.slices-1)+forb.scanner.pulseduration		% ja, bekijk nu of een pulse moet worden gegenereerd				triggercount=floor(tijd2/forb.scanner.sliceinterval);		tijd3=tijd2-triggercount*forb.scanner.sliceinterval;		% we genereren een trigger als het trigger moment nog niet voorbij is		if tijd3 <= forb.scanner.pulseduration			forb.status(forb.trigger)=1;		end	endendfor i=1:forb.nbuttons	if forb.status(i)>=1		buttonisdown=1;	endendif forb.status(forb.trigger)>=1	trigger=1;endif time==-1 % if time still has not been set we do it here	time=GetSecs;endforb.time=time;