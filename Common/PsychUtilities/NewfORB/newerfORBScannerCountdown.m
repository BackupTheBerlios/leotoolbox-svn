function forb=newerfORBScannerCountdown(window, forb, skip, background, txtcol)% 17-02-02	fwc		toegevoegd methode om op basis van slice gap volume te triggerenquitkey=KbName('esc');modifierkey=KbName('apple');fontsize=24;textxpos=fontsize;textypos=fontsize+10;font='Courier';oldfont=SCREEN(window,'TextFont',font);oldfontsize=SCREEN(window,'TextSize',fontsize);if 1	proceedafterloadingtext='Druk op spatiebalk na laden';	waitingforscannertext='Wacht op scanner';	startsafternextscantext='Begint bij de volgende scan';	waitingforscanstext='Wacht nog op';else	proceedafterloadingtext='Press spacebar when loaded';	waitingforscannertext='Waiting for scanner';	startsafternextscantext='Proceeds upon next scan';	waitingforscanstext='Waiting for another';endwhite=WhiteIndex(window); % always use white textblack=BlackIndex(window);if nargin<=3 | isempty(background)	background=(white+black)/2; % set background to middle gray when unknownendif nargin<=4 | isempty(txtcol)	txtcol=white;endrect=SCREEN(window, 'rect');rect(3)=rect(3)/2-5; rect(4)=textypos+fontsize; SCREEN(window,'FillRect',background, rect);% wait for space bar press to continue after scanner loadingSCREEN(window,'DrawText', proceedafterloadingtext, textxpos, textypos, txtcol);waitForSpaceBar;if forb.scanner.simulate==1 & forb.scanner.start < 0 % to start simulation	forb.scanner.start=getsecs;endSCREEN( window, 'FillRect', background, rect);if skip >= 0			% remove any pending trigger pulses (or key presses) by closing (and later re-opening port)	newforbclose(forb);			forb=newforbopen( forb ); % open the port for receiving responses		nextvolume=0;	updatescreen=0;	triggercount=0;	volumecount=0;	triggerlogged=0;	prevtriggertime=-1;	prevvolumetime=-1;		% wait for scanner to generate first trigger	SCREEN(window,'DrawText', waitingforscannertext, textxpos, textypos, txtcol);	while 1		[keyIsDown,secs,keyCode] = KbCheck;		if keyCode(modifierkey) & keyCode(quitkey)			break;		end			[isbuttondown, istrigger, time, forb]=newforbcheck(forb);			% tel aantal triggers		if 1			if istrigger==1				if triggerlogged==0					triggercount=triggercount+forb.status(forb.trigger);					delta=time-prevtriggertime;					prevtriggertime=time;								% test of op basis van tijd tussen triggers of we niet al begonnen zijn met 't nieuwe volume					if triggercount > 1 % pas op bij eerste trigger, moet niet als volume worden geteld						if getsecs-prevvolumetime>forb.scanner.nextvolumetime & delta > forb.scanner.volumegaptime							nextvolume=1;						else							nextvolume=0;						end					end					if triggercount>=forb.scanner.slices | nextvolume==1						volumecount=volumecount+1;						if nextvolume==1							triggercount=1;						else							triggercount=mod(triggercount, forb.scanner.slices);						end						delta=time-prevvolumetime;						prevvolumetime=time;					end					triggerlogged=1;					updatescreen=1;				end			else				triggerlogged=0;			end		else				if istrigger==1				if triggerlogged==0					triggercount=triggercount+forb.status(forb.trigger);					if triggercount>= forb.scanner.slices						volumecount=volumecount+1;						triggercount=mod(triggercount,forb.scanner.slices);					end					triggerlogged=1;					updatescreen=1;				end			else				triggerlogged=0;			end		end				% onderbreek wanneer aantal volumes/triggers gehaald is (dus (eerste trigger van) volume dat niet geskipped moet worden		if forb.scanner.slices ==1			if volumecount>skip				break;			end		else			if volumecount>=skip & triggercount>=1				break;			end		end			if updatescreen==1			SCREEN( window, 'FillRect', background, rect);			if volumecount==skip				txt=startsafternextscantext;			else				if forb.scanner.slices > 1					txt=sprintf('volume %3d, slice %4d', skip-volumecount, forb.scanner.slices-triggercount);				else					txt=sprintf('volume %3d', skip-volumecount);				end				end			SCREEN(window,'DrawText', txt, textxpos, textypos, txtcol);			updatescreen=0;		end	end	endSCREEN( window, 'FillRect', background, rect);