% fORB input functionclear all;port=1; %2 for printer, 1 for serial, 0 for keyboard onlykeyset=2;usekeys=1;usetrigger=0;nslices=26;cycles=200000;quitkeyname='q';quitkey=KbName(quitkeyname);fprintf('Test program for the fORB response box.\n\n');forb=newforbinit(port, keyset, usekeys, usetrigger);if forb.error~=0	fprintf('Error initialising the fORB response box.\n\n');	return;else		fprintf('Press ''apple''+''%s'' to quit the program.\n\n', quitkeyname);	newPriority=MaxPriority(0,['GetSecs'],['KbCheck']);	oldPriority=Priority(newPriority);	stop=0;	released=ones(forb.nbits,1);	prevdatatime=0;	datatime=0;	deltadatatime=0;	prevvolumetime=0;	volumetime=0;	deltavolumetime=0;	prevtriggertime=0;	triggertime=0;	deltatriggertime=0;	looptime=zeros(cycles,1);	bytecount=zeros(cycles,1);	triggercount=0;	volumecount=0;	[data, m, n]=newrawforbcheck(forb);	if ~isempty(data)		for i=1:forb.nbits			if bitand(data, forb.bit(i))				fprintf( '1');			else				fprintf( '0');			end		end		fprintf( '\n');	end			FlushEvents('keyDown');	% discard all the chars from the Event Manager queue.	count=1;	forb.timeoutSecs=2/1000;	looptime(count)=getsecs;	looptime(count)=getsecs;	while stop==0		[keyIsDown,secs,keyCode] = KbCheck;		if keyCode(quitkey)			break;		end			%start=getsecs;	%	[isbuttondown, istrigger, time, forb]=newforbcheck(forb);		%finish=getsecs;	%	[data, m, n]=newrawforbcheck(forb);		data=SERIAL('Read',forb.port, forb.timeoutSecs);		[m,n]=size(data);				if ~isempty(data)			prevdatatime=datatime;			datatime=getsecs;			deltadatatime=datatime-prevdatatime;		%	fprintf( '%3d\t%3d\t', m, n);			bytecount(count)=n;			for k=1:n				if bitand(data(k), forb.bit(forb.trigger))					if released(forb.trigger)==1						triggercount=triggercount+1;						released(forb.trigger)=0;						prevtriggertime=triggertime;						triggertime=getsecs;						deltatriggertime=triggertime-prevtriggertime;						fprintf('Trigger\t%4d\t%6.1f\n', triggercount, deltatriggertime*1000 );					end				else					released(forb.trigger)=1;				end			end			if deltatriggertime>0.3 & getsecs-volumetime>2.0				volumecount=volumecount+1;				prevvolumetime=volumetime;				volumetime=getsecs;				deltavolumetime=volumetime-prevvolumetime;				triggercount=1;				fprintf('\t\t\tVolume\t%3d\t%6.1f\n', volumecount, deltavolumetime*1000 );			end		else			released=ones(forb.nbits,1);		end			count=count+1;		looptime(count)=getsecs;	end	Priority(oldPriority);	newforbclose(forb);endlooptime=looptime-looptime(1);looptime=looptime*1000;looptime2=looptime(2:count)-looptime(1:count-1);[n,x]=hist(looptime2,40);n(1)=0;%bar(x,n);%plot(bytecount(1:count-1), looptime2(1:count-1));%checktime=checktime*1000;%[n,x]=hist(checktime, 40);%n(1)=0;%figure;%bar(x,n);mlooptime=mean(looptime2);maxlooptime=max(looptime2);minlooptime=min(looptime2);fprintf('\nDuration of looptest: %.1f secs.\n', looptime(count)-looptime(1) );fprintf('\nLoop doorlooptime (mean, max, min): %.3f ms, %.3f ms , %.3f ms\n', mlooptime, maxlooptime, minlooptime);FlushEvents('keyDown');	% discard all the chars from the Event Manager queue.fprintf('\nBye!\n\n');